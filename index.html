<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Outlier Reconstruction</title>

  <style>
  canvas {
    background-color: black;
    border: 2px solid blue;
  }

  .parent{
    width: 90%;
    margin: 10px auto;
  }

  .first {
    /*border: 2px solid black;*/
    float: left;
    width:30%;
    height: 150px
    box-sizing: border-box;
  }

  .second{
    /*border: 2px solid black;*/
    float: left;
    margin-left: 5%;
    width:30%;
    height: 150px
    box-sizing: border-box;
  }

  .third{
    /*border: 2px solid black;*/
    float: right;
    width:30%;
    height: 150px
    box-sizing: border-box;
  }

  .preset_btn{
    float: left;

  }
  </style>

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>


</head>
<body onload="init()">

  <h1 style="text-align: center;">Outlier Reconstruction</h1>

  <p style="text-align: center;">Demo coded by Hyerim Jeon and <a href="https://swyoon.github.io/">Sangwoong Yoon</a>.</p>
  <br><br>

  <div class="container">
    <div class="row">
      <p>
        <b>Outlier reconstruction</b> is a phenomenon that an autoencoder (AE) successfully reconstructs an outlier.
        In the demo below, we demonstrate that AE trained on MNIST is capable of reconstrcting diverse images that are clearly not MNIST.  
        Outlier reconstruction is detrimental for an autoencoder-based outlier detector, 
        as the reconstructed outliers will be misclassified as an inlier.
      </p>
      <p>
        In our <a href="https://arxiv.org/abs/2105.05735">ICML 2021 paper</a>, 
        we propose a novel autoencoder called <b>Normalized Autoencoder (NAE)</b> where AE is interpreted as an energy-based model by setting the reconstruction error as the energy function.
        The outlier reconstruction is naturally suppresed in NAE through the enforcement of the normalization constraint.
      </p>
    </div>
  </div>

  <!-- 사실 이 아래 덩어리는 마지막으로 보내고 싶은데, 그러면 layout이 망가짐. 나중에 옮길 것. -->
  <div class="container">
    <div class="row">
      <p>
        To learn more about outlier reconstruction and NAE, please check out our paper 
        <a href="https://arxiv.org/abs/2105.05735">Autoencoding Under Normalization Constraint (Yoon, Noh, and Park, 2021)</a>.
        If you want to cite outlier reconstruction, NAE, or the demo, please use the following bibtex:
      </p>
    </div>
  </div>

  <div class="container">
    <div class="row">
    <pre style="background-color: #eee; border: 1px solid #999">
    @InProceedings{yoon21autoencoding,
      title = 	 {Autoencoding Under Normalization Constraints},
      author =       {Yoon, Sangwoong and Noh, Yung-Kyun and Park, Frank},
      booktitle = 	 {Proceedings of the 38th International Conference on Machine Learning},
      pages = 	 {12087--12097},
      year = 	 {2021},
      editor = 	 {Meila, Marina and Zhang, Tong},
      volume = 	 {139},
      series = 	 {Proceedings of Machine Learning Research},
      month = 	 {18--24 Jul},
      publisher =    {PMLR},}</pre>  
    </div>
  </div>


  <div class="parent">
    <div class="first">Input</div>
    <div class="second">AE Reconstruction</div>
    <div class="third">NAE Reconstruction</div>
  </div>

  <div class="parent">
    <div class="first">
      <canvas width="360" height="360" id="Inputcanvas"></canvas>
    </div>

    <div class="second">
      <canvas width="360" height="360" id="AEcanvas" ></canvas>
    </div>

    <div class="third">
      <canvas width="360" height="360" id="NAEcanvas"></canvas>
    </div>

  </div>

  <div class="parent">
    <div class="first">
      <button onclick="javascript:clearArea();return false;">Clear</button>
    </br></br>
      <span>Preset Inputs</span></br>
      <div class="preset_btn">
      <button type="button" id="mnist3_btn" onclick="javascript:load_image('mnist_3.jpg');return false;">
        <img src="./preset_image/mnist_3.jpg"></button>

      <button type="button" id="mnist7_btn" onclick="javascript:load_image('mnist_7.jpg');return false;">
        <img src="./preset_image/mnist_7.jpg"></button>

      <button type="button" id="omniglot1_btn" onclick="javascript:load_image('omniglot1.jpg');return false;">
        <img src="./preset_image/omniglot1.jpg"></button>

      <button type="button" id="omniglot2_btn" onclick="javascript:load_image('omniglot2.jpg');return false;">
        <img src="./preset_image/omniglot2.jpg"></button>

      <button type="button" id="fashionmnist_btn" onclick="javascript:load_image('fashionmnist.jpg');return false;">
        <img src="./preset_image/fashionmnist.jpg"></button>

      </div>

    </div>
    <div class="second">
      <span>
        Reconstruct Error:
      </span>
    </div>
    <div class="third">
      <span>
        Reconstuct Error:
      </span>
    </div>
  </div>



  <script>
  // 원본 이미지 사이즈는 28*28로 통일
  function load_image(image_name){
    var can=document.getElementById("Inputcanvas");
    var ctx=canvas.getContext("2d");
    var image=new Image();
    image.src="./preset_image/"+image_name;
    image.addEventListener("load", () => {ctx.drawImage(image, 0, 0, 360, 360)})
  }



  var canvas, context;

  function init() {
    canvas = document.getElementById("Inputcanvas");
    context = canvas.getContext("2d");


    context.lineWidth = 3; // 선 굵기를 2로 설정
    context.strokeStyle = "white";

    // 마우스 리스너 등록. e는 MouseEvent 객체
    canvas.addEventListener("mousemove", function (e) { move(e) }, false);
    canvas.addEventListener("mousedown", function (e) { down(e) }, false);
    canvas.addEventListener("mouseup", function (e) { up(e) }, false);
    canvas.addEventListener("mouseout", function (e) { out(e) }, false);
  }

  var startX=0, startY=0; // 드래깅동안, 처음 마우스가 눌러진 좌표
  var drawing=false;
  function draw(curX, curY) {
    context.beginPath();
    context.moveTo(startX, startY);
    context.lineTo(curX, curY);
    context.stroke();
  }
  function down(e) {
    startX = e.offsetX; startY = e.offsetY;
    drawing = true;
  }
  function up(e) { drawing = false; }
  function move(e) {
    if(!drawing) return; // 마우스가 눌러지지 않았으면 리턴
    var curX = e.offsetX, curY = e.offsetY;
    draw(curX, curY);
    startX = curX; startY = curY;
  }
  function out(e) { drawing = false; }


  function clearArea() {
    // Use the identity matrix while clearing the canvas
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
  }
</script>
</body>
</html>
